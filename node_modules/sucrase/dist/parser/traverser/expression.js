"use strict";Object.defineProperty(exports, "__esModule", {value: true});/* eslint max-len: 0 */

// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts ‚Äî that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser











var _flow = require('../plugins/flow');
var _index = require('../plugins/jsx/index');
var _types = require('../plugins/types');









var _typescript = require('../plugins/typescript');












var _index3 = require('../tokenizer/index');
var _keywords = require('../tokenizer/keywords');
var _state = require('../tokenizer/state');
var _types3 = require('../tokenizer/types');
var _charcodes = require('../util/charcodes');
var _identifier = require('../util/identifier');
var _base = require('./base');






var _lval = require('./lval');







var _statement = require('./statement');









var _util = require('./util');

 class StopState {
  
  constructor(stop) {
    this.stop = stop;
  }
} exports.StopState = StopState;

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function (s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.
 function parseExpression(noIn = false) {
  parseMaybeAssign(noIn);
  if (_index3.match.call(void 0, _types3.TokenType.comma)) {
    while (_index3.eat.call(void 0, _types3.TokenType.comma)) {
      parseMaybeAssign(noIn);
    }
  }
} exports.parseExpression = parseExpression;

/**
 * noIn is used when parsing a for loop so that we don't interpret a following "in" as the binary
 * operatior.
 * isWithinParens is used to indicate that we're parsing something that might be a comma expression
 * or might be an arrow function or might be a Flow type assertion (which requires explicit parens).
 * In these cases, we should allow : and ?: after the initial "left" part.
 */
 function parseMaybeAssign(noIn = false, isWithinParens = false) {
  if (_base.isTypeScriptEnabled) {
    return _typescript.tsParseMaybeAssign.call(void 0, noIn, isWithinParens);
  } else if (_base.isFlowEnabled) {
    return _flow.flowParseMaybeAssign.call(void 0, noIn, isWithinParens);
  } else {
    return baseParseMaybeAssign(noIn, isWithinParens);
  }
} exports.parseMaybeAssign = parseMaybeAssign;

// Parse an assignment expression. This includes applications of
// operators like `+=`.
// Returns true if the expression was an arrow function.
 function baseParseMaybeAssign(noIn, isWithinParens) {
  if (_index3.match.call(void 0, _types3.TokenType._yield)) {
    parseYield();
    return false;
  }

  if (_index3.match.call(void 0, _types3.TokenType.parenL) || _index3.match.call(void 0, _types3.TokenType.name) || _index3.match.call(void 0, _types3.TokenType._yield)) {
    _base.state.potentialArrowAt = _base.state.start;
  }

  const wasArrow = parseMaybeConditional(noIn);
  if (isWithinParens) {
    parseParenItem();
  }
  if (_base.state.type & _types3.TokenType.IS_ASSIGN) {
    _index3.next.call(void 0, );
    parseMaybeAssign(noIn);
    return false;
  }
  return wasArrow;
} exports.baseParseMaybeAssign = baseParseMaybeAssign;

// Parse a ternary conditional (`?:`) operator.
// Returns true if the expression was an arrow function.
function parseMaybeConditional(noIn) {
  const wasArrow = parseExprOps(noIn);
  if (wasArrow) {
    return true;
  }
  parseConditional(noIn);
  return false;
}

function parseConditional(noIn) {
  if (_base.isTypeScriptEnabled || _base.isFlowEnabled) {
    _types.typedParseConditional.call(void 0, noIn);
  } else {
    baseParseConditional(noIn);
  }
}

 function baseParseConditional(noIn) {
  if (_index3.eat.call(void 0, _types3.TokenType.question)) {
    parseMaybeAssign();
    _util.expect.call(void 0, _types3.TokenType.colon);
    parseMaybeAssign(noIn);
  }
} exports.baseParseConditional = baseParseConditional;

// Start the precedence parser.
// Returns true if this was an arrow function
function parseExprOps(noIn) {
  const startTokenIndex = _base.state.tokens.length;
  const wasArrow = parseMaybeUnary();
  if (wasArrow) {
    return true;
  }
  parseExprOp(startTokenIndex, -1, noIn);
  return false;
}

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.
function parseExprOp(startTokenIndex, minPrec, noIn) {
  if (
    _base.isTypeScriptEnabled &&
    (_types3.TokenType._in & _types3.TokenType.PRECEDENCE_MASK) > minPrec &&
    !_util.hasPrecedingLineBreak.call(void 0, ) &&
    (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as) || _util.eatContextual.call(void 0, _keywords.ContextualKeyword._satisfies))
  ) {
    const oldIsType = _index3.pushTypeContext.call(void 0, 1);
    _typescript.tsParseType.call(void 0, );
    _index3.popTypeContext.call(void 0, oldIsType);
    _index3.rescan_gt.call(void 0, );
    parseExprOp(startTokenIndex, minPrec, noIn);
    return;
  }

  const prec = _base.state.type & _types3.TokenType.PRECEDENCE_MASK;
  if (prec > 0 && (!noIn || !_index3.match.call(void 0, _types3.TokenType._in))) {
    if (prec > minPrec) {
      const op = _base.state.type;
      _index3.next.call(void 0, );
      if (op === _types3.TokenType.nullishCoalescing) {
        _base.state.tokens[_base.state.tokens.length - 1].nullishStartIndex = startTokenIndex;
      }

      const rhsStartTokenIndex = _base.state.tokens.length;
      parseMaybeUnary();
      // Extend the right operand of this operator if possible.
      parseExprOp(rhsStartTokenIndex, op & _types3.TokenType.IS_RIGHT_ASSOCIATIVE ? prec - 1 : prec, noIn);
      if (op === _types3.TokenType.nullishCoalescing) {
        _base.state.tokens[startTokenIndex].numNullishCoalesceStarts++;
        _base.state.tokens[_base.state.tokens.length - 1].numNullishCoalesceEnds++;
      }
      // Continue with any future operator holding this expression as the left operand.
      parseExprOp(startTokenIndex, minPrec, noIn);
    }
  }
}

// Parse unary operators, both prefix and postfix.
// Returns true if this was an arrow function.
 function parseMaybeUnary() {
  if (_base.isTypeScriptEnabled && !_base.isJSXEnabled && _index3.eat.call(void 0, _types3.TokenType.lessThan)) {
    _typescript.tsParseTypeAssertion.call(void 0, );
    return false;
  }
  if (
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._module) &&
    _index3.lookaheadCharCode.call(void 0, ) === _charcodes.charCodes.leftCurlyBrace &&
    !_util.hasFollowingLineBreak.call(void 0, )
  ) {
    parseModuleExpression();
    return false;
  }
  if (_base.state.type & _types3.TokenType.IS_PREFIX) {
    _index3.next.call(void 0, );
    parseMaybeUnary();
    return false;
  }

  const wasArrow = parseExprSubscripts();
  if (wasArrow) {
    return true;
  }
  while (_base.state.type & _types3.TokenType.IS_POSTFIX && !_util.canInsertSemicolon.call(void 0, )) {
    // The tokenizer calls everything a preincrement, so make it a postincrement when
    // we see it in that context.
    if (_base.state.type === _types3.TokenType.preIncDec) {
      _base.state.type = _types3.TokenType.postIncDec;
    }
    _index3.next.call(void 0, );
  }
  return false;
} exports.parseMaybeUnary = parseMaybeUnary;

// Parse call, dot, and `[]`-subscript expressions.
// Returns true if this was an arrow function.
 function parseExprSubscripts() {
  const startTokenIndex = _base.state.tokens.length;
  const wasArrow = parseExprAtom();
  if (wasArrow) {
    return true;
  }
  parseSubscripts(startTokenIndex);
  // If there was any optional chain operation, the start token would be marked
  // as such, so also mark the end now.
  if (_base.state.tokens.length > startTokenIndex && _base.state.tokens[startTokenIndex].isOptionalChainStart) {
    _base.state.tokens[_base.state.tokens.length - 1].isOptionalChainEnd = true;
  }
  return false;
} exports.parseExprSubscripts = parseExprSubscripts;

function parseSubscripts(startTokenIndex, noCalls = false) {
  if (_base.isFlowEnabled) {
    _flow.flowParseSubscripts.call(void 0, startTokenIndex, noCalls);
  } else {
    baseParseSubscripts(startTokenIndex, noCalls);
  }
}

 function baseParseSubscripts(startTokenIndex, noCalls = false) {
  const stopState = new StopState(false);
  do {
    parseSubscript(startTokenIndex, noCalls, stopState);
  } while (!stopState.stop && !_base.state.error);
} exports.baseParseSubscripts = baseParseSubscripts;

function parseSubscript(startTokenIndex, noCalls, stopState) {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsParseSubscript.call(void 0, startTokenIndex, noCalls, stopState);
  } else if (_base.isFlowEnabled) {
    _flow.flowParseSubscript.call(void 0, startTokenIndex, noCalls, stopState);
  } else {
    baseParseSubscript(startTokenIndex, noCalls, stopState);
  }
}

/** Set 'state.stop = true' to indicate that we should stop parsing subscripts. */
 function baseParseSubscript(
  startTokenIndex,
  noCalls,
  stopState,
) {
  if (!noCalls && _index3.eat.call(void 0, _types3.TokenType.doubleColon)) {
    parseNoCallExpr();
    stopState.stop = true;
    // Propagate startTokenIndex so that `a::b?.()` will keep `a` as the first token. We may want
    // to revisit this in the future when fully supporting bind syntax.
    parseSubscripts(startTokenIndex, noCalls);
  } else if (_index3.match.call(void 0, _types3.TokenType.questionDot)) {
    _base.state.tokens[startTokenIndex].isOptionalChainStart = true;
    if (noCalls && _index3.lookaheadType.call(void 0, ) === _types3.TokenType.parenL) {
      stopState.stop = true;
      return;
    }
    _index3.next.call(void 0, );
    _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;

    if (_index3.eat.call(void 0, _types3.TokenType.bracketL)) {
      parseExpression();
      _util.expect.call(void 0, _types3.TokenType.bracketR);
    } else if (_index3.eat.call(void 0, _types3.TokenType.parenL)) {
      parseCallExpressionArguments();
    } else {
      parseMaybePrivateName();
    }
  } else if (_index3.eat.call(void 0, _types3.TokenType.dot)) {
    _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    parseMaybePrivateName();
  } else if (_index3.eat.call(void 0, _types3.TokenType.bracketL)) {
    _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    parseExpression();
    _util.expect.call(void 0, _types3.TokenType.bracketR);
  } else if (!noCalls && _index3.match.call(void 0, _types3.TokenType.parenL)) {
    if (atPossibleAsync()) {
      // We see "async", but it's possible it's a usage of the name "async". Parse as if it's a
      // function call, and if we see an arrow later, backtrack and re-parse as a parameter list.
      const snapshot = _base.state.snapshot();
      const asyncStartTokenIndex = _base.state.tokens.length;
      _index3.next.call(void 0, );
      _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;

      const callContextId = _base.getNextContextId.call(void 0, );

      _base.state.tokens[_base.state.tokens.length - 1].contextId = callContexè‘rB|ÉΩŸ!|.4#ﬂg=‰Vè◊™™£QXT¥· ãUŸÑ üoU2@\|Qí∆8ÈaÕWidﬁÌL∑ÛIx≥8äê8}k*π.¡ÏË˛AÌ≈åÆÆÊ›±iKMà¬⁄r∑E™hX“µG9Â¬kZ€<¶•„X«≤⁄eQ’t”pâ`'A?∂ÊŒ/·ƒóX&pæ—”u_™Ì…Å„Ï\≠h}¡P°ÁÇ8‘C"w∑†ç„ËÄ_Öî)Ûj‹≥ |óµﬁ"k3v`ZΩ™ ZE]c.ö˚§p=‘Â€U¢IU∂BÏ∆E
Äã©Y?ÄÑÂ°Ì≠8ùËB &‰=¬Z8ê@å9–ØøM≥pTNÇ‡÷ÔhÜdÉi¡
o'û0ñ¡ˆ}
Ó‚ 5Ní9;W9(”4πO¢˘∏qéóπKX2– ”Lfba†∆∑Á˛àZØ{Xhî∂†y~íÁ∏z(D	‘ÌYÿJd îÁM!Ë:Xû#•FŒÜäg ≥_Ë§îôº Íù)∞`*§Ã:…
QÆe+√W1˘π>éuµÂ¡X¯8MOx?ı7&™∫§HÊõs∑≤;·,Ä¯®’‹4™\_–íÙœFqgUL‰g‘Ò∑Ÿ!êº ™‚Ê–•ﬁ∆¯<”+è⁄dÁó8öÔx|INﬁº):¬∏›√É\EF6jØî¶
Á…yH289,éi˛≥gã?q£:¯ﬁÌy©s@*Ÿﬁt·u£”ÑÈñ_aﬁåWÚ›pƒ/∞“!Â,q"r¶£	•ûr,~’,≥‡9¶⁄gxLbkW@'/Â\qı∏FÏÉÈùFú„,ûb]|	ñr1˙=g¶LÚ(Å√≤ﬂãŸ.kuû·
ˇt£ÑxΩÿ•‚_Îf
æRˆ‰€:ˆA8äAH¡≥–∂É˜Ö=>Pv¥îiLtbÃÍêÉ"$ˆß¸œÌK_aìDºÔÙXŒÏûƒ‡%0A!Ûè¡∆Ma∆g˛ÔV[£—3+h¶«c3ÜFè%äEû.W‰¸?K⁄.ﬁ5µ∑	/Èùë˘b⁄7√™h3UnÂÉJx˜‹@äoÀMÈ+K¯â≠#Y2lôi#¢é_gL´íœ>.÷ù≤p˘¡Œ˝G§dÆ£ AVﬁlO“Äı?®6–CΩxã<%æ-ÒÆ¯«<9ºØö^#œ1º4p‹ø;ı(nΩ·xwΩëÚ§< $˘òSßUÕƒö—°CËÜª;L„ÉJÛı ˜Û™˛¯x.[ﬁ”g`ö“V`Nh≈ú´ÅµcCWÚ∆ßﬂF´ù{¨°∑⁄ÜY‚√fc≈˚‰∆	3îG¿\<œÄë◊c∆¡ﬂÃ´ªßñÿ◊}˚ ?ˇÙ˝ˇ≠˚ˇ¨ÎˇﬂŒﬂÄ(≥uáé †ˇ˜∫˛˜≥æˇÛ˙ˇÀUﬂ#ÅˆœÆæÄs˘[ÉQ‰¸·ïd#Ü¬GòÀ	Ù~iµÅÏ˝¸∑97Ë÷Ãp˛∏˜Ä_‹≈?MÒapﬂbË˝ ëø~“˛‹Ûg‡óLÃåÛ˛fÜDHÜÑXDÜ˚Ü«0ê˙ñ≈‚ôë˝a^èﬂÕw˛[«ouyÑ˛A˛€Q(™Ñ˚áº“œ%ø')`Äzààˆ¸‰Ä5i	èzzÉ/*G¡ıµ3ó^ëÊjÃ¢_¶ò6 ï¶ˇÑî¯1â ÄTtSø‘≠˛ÒGZØœ¿_iﬁΩ"µ∞jáÒ6IÛ5qÕ.ü)ÛÓn}›mÛ;∞ª·‡S>õùæ˚)õxØ”æÏ˛Ë‹√Õ ı∂±¿.7zq=•+æ„˜¶g¬ÊPåF⁄Ã§cA¸ã®qù∑›iãâ:Áfo`¯’˚˚‰úfÊj∆ˆ^ÊK“,wÿj´◊˚»'_xÂ¸„ EûYÆƒ÷€wnvŸàãDÅ2Å å^ëÑu-  2ªä2òù”„‡∞Dã≈îâﬁ ‘>ÎŸt Äö%:Ä¿x õ2ïv]C€&7b>õú≤„—™Ω˚íñßHì¸^ÜäæÑü2¿ç i∫ß‹"ﬂ˛|$÷Foå{˝l&∂“ˇ´p ∞ê(¡ ΩM‹tQ˜RÚ[:_f¡8•ëûâŸE¡Ñ€ß'∞»Dsèã~1't8d/•.3Ñ·ü/v96Ôvöº>4äÕçWÆáÊpËêN¬ÜQ@ç5xë0”ˆ]ój¢ì∆»ì¶kß˛ì ÒkoÃ¡-®!ml˘≠ﬁ6˚◊Y K^êcj±øª‰˘{1!PfÎFÄÄ˚N¯´¯∏ôÕ	‰`'4ŸΩJ ä0¡D™°Xt(Ñ¥Ú*§Ú5©∏*Wº9≈Ø`¶I4·yXÕ	7©TÜû§)<¸SrÎ\#º°+ÿ…∞iåÑp°–]Î*Ñ†π!p6zbÃ9ë@µ[qı˘ûáHw~U˜™W©ÕiXa˚çC√˛Rg7ú0—A∫¢˙Y-¬ÜÏÏﬂ ˙|ímB{^.˛êq4ÙáØ›zÿ¥ãè¬·¢Î¥ôíT§—z⁄Cin‰!ê≈€h±é“}U,72·wÄ%§ ∂SK˚j
>€r“Õà^Q„éB÷Œ d(?ë4q0∞Bc®ãë©£»2xZtÛ√eÙ
cº.r=¸î˚W˘dÂ_n:˜ƒ˛¸à¸¬Gppè“ü˝ •—ôåcå{0ÍÒqˇ®YÚP∫ ñ*˛r°<+gj‰2'Ëá–A`7¬á ï∆d$ („x! "∆¸F¬;6w¸%5}z{ôó'Å2z·U2∆È]^,- ı"w|	úèÕ7ÛÿÆO|»‹˚‹…s¸Ñ7#f6kÆ |aπëë+æ3‰zÀ˝%2[Õa3Áef@Ê¸§æn6f·`û9öù!ÿÀ4ì7√YQ—Í≠ÊF‹‘1¨∞§/ï≠‹µ…ÜD©;¨ÂÖ§ÆDS™ƒÏcπq¿ÀXÊÎc˛k•ÖL~—Ïä´Ì∑5ùd—#HΩÖªK»∏€S€≤&"›BJrkÆà1†0¡EDJ∂$≈Ê∑9≠w¶˝w¡5ı˜©;VPlw≈!;kíZa‘pH¢l¶…6l[Q∑ÚùÌ}òCåån7–0Ü`JD9òµ4∏7†RætÛC5˙4˙g\•AˇB›EÑ)cïI≤o@!≠%hiñµëK≠ﬁJÃú≈∫Ω∞¬÷µI.›„TZ4Ès& ”w—Y]Rù§_êNØé¬∂ŸûWj§n5aShD\~àhMá∂˜~œÁ	—Fµ8à1]T—z^bZí	ù§¿Ú®HØ®‡TÙ¥¢FŸΩúÇÅé˘\®Qπ˙ñàÚ†éœü¡vO¥fÛ©Åp/÷˚|æ◊-a—~¥Å‹2Ø£¥1–˛B∏+B˜«À‘Îéì˚1¿R≈∞êﬂmp'!5YûÀê·ë£Çó@ k åËAßàI¡z„¸08Z`áF‘}®≠Ö˘ ¸8z0ˆbÚÉ"≈…{ ûO≤‡Ô9î¯/m;:G'ÒÛ◊ıﬁ8»˝—%ÑÈ-Ûwºl¡I¸GœÜëxÌo∑çx}_ò„/ÁƒÜŸ,wÌœt›n©ŒXw˘Ûz?ıƒø∏¿ó,¯◊?Úóº	˘ê	Òìü^&!ëÚsH y—ü∂.AÚ/˛.ˇy·ÛÆø∞(êÃL$¿4°ñ˜˝ç∑∆∆: ÇÄ`˚Ωh'¬ÅOIÅ j„ålÑm)ÇY»Ü<hH"1TŸ@>Êïˇ]#¿ÏÏ”-¡B˜wÛü"êﬁ7¡û[ù.Î∫»⁄ÖÊÓ][7⁄Ü˚U}ÌwÄZÍL˜¡›ãï~”Zø‰nç:øÆ´õFıK∆ÆÔÆ™=€]k3wÕÏ∏gÎL_ÚßŒò5s™˜ÎÜ øNÒÃ√Î1Ä	i¥Ùºh⁄Ízó¯rí˚µﬁ˛˜/dŸœÒMõ$>‚/§Gobµ∂Y÷èˇÆÙí¸ŸSôª≈$À”Æå∏ÔÓÊ<•ÃI0@Ü!Ë ·«(A-!–1HQ‡ë5 Q"!òŸ*îúä	–»≠E5dP‘;r∑ë@¿0PPh3C¡≠Ö31ö•8íàèWéÖ£•ŸUGı€≥ä MËü#]&«€Ó≈á]ÍfM^wíµyØApHtRC–õOg´¥ƒ´øëlÇ¬©"EµiíH{Sˇ
eËN_í3ê&û“∞ÊçÈ¬l`P˙ı÷ÓıÁ?Îó	(tCÏ§†àë<Çtóm23§B.Aç¥çÆŸ•ÿ	¿ÑŒZP+–õjX«U-4 Ã>D#¸I™√ ü!éGÚL6Aëﬁ=íAWïh‡ò
ﬁ‡¶.}]@-,
Ë
P3≤`†buÊq…1¡∂g…Í©J»”èÖ\d|¯ÛBEH[ç]@pj:oÔ/˛◊Î	tÅΩëDNèÿpóÑ.áOÇs$¸'¢°ã⁄}ÅñÀ¿eh%ÔÉYIsÚÛà$,·tTqU∑ÑWÓ¢Â8@6E  ≠·ZU -ä@¨à%íö2¥c¿YiË=î∏‹H¡[ÇÎ>h£◊Nsè∞av¨ÎKGÆ2\l\A=¯rÏì€ã@ñ˙Ä`aD·}nÄuîy‰Y*áR“ì0.jÂÔù•:M=®b«#º8ÉJl:h-vımD´s†Ü nÃè¨¥U>ﬂI∞é+¸ÄQ-∑±Ä°èPà3ﬂ¢	È¶®€V=
ÀÄı	ÆC˚S2î˝ò"–≈ueãL;ö_È˛c,Xwå§5–jÊ‡Âë˛%ı©—±ıãî®à‹ñ’ê4ÅÀg˛.h;iÁπÎ‡™¢¡j˝4?k|ó˝˛L›ı◊r´µó§)˝¿RE¿π™'4¿ûØÔﬂùÔÜ·¬©úsŒ-´˘BOÀ¡Ú…´–Ÿ Ó≈aõGÜ˘0πv_Ì°«é;¯‰†ˇ¥¯K0-*7Û˛xñp«ñπ∏ï*3íN∑öã≈^¨±≥7EkÙ5âÇ‚*ç∆(Ô€¶íøÏ≠Ô=Ãˆ}%P}%¿|:⁄ü‚ÏÁíÛöœH÷cﬂìôe1˙ó·¶o≤*ÇCØ†å¢O;}≥·Ò[æÏ	Ÿ¯lb÷)ò{õ~öëïnÆe<ôÛ_÷îî=~Y’DÚ3ıﬁΩ‰˙>ÀSº∏â¨µ‹ûÿ~π_'œS €Jµ€Ω°_≠RDﬂ[⁄¡∑m,ëEJ €˚~!—q$øœZ)OÁÊÕ‹™ıÀ>≤ΩÛd>ùûù§˘6ò|Û∂OÚ;IﬁÃ≈bÃ¸ÁÃÃJ,ü€ô9ê!∆t√TUª•§mR2©K¯)
p[ër È¸+"≈5æ*¯Ê k!°=¨j%«r«Úƒ<LNFèUòQ⁄lƒ&ßû≥ü…†nY~†! Wõ≤4ÄDÜ”ß:ávbigint:
    case _types3.TokenType.decimal:
    case _types3.TokenType.string:
    case _types3.TokenType._null:
    case _types3.TokenType._true:
    case _types3.TokenType._false:
      _index3.next.call(void 0, );
      return false;

    case _types3.TokenType._import:
      _index3.next.call(void 0, );
      if (_index3.match.call(void 0, _types3.TokenType.dot)) {
        // import.meta
        _base.state.tokens[_base.state.tokens.length - 1].type = _types3.TokenType.name;
        _index3.next.call(void 0, );
        parseIdentifier();
      }
      return false;

    case _types3.TokenType.name: {
      const startTokenIndex = _base.state.tokens.length;
      const functionStart = _base.state.start;
      const contextualKeyword = _base.state.contextualKeyword;
      parseIdentifier();
      if (contextualKeyword === _keywords.ContextualKeyword._await) {
        parseAwait();
        return false;
      } else if (
        contextualKeyword === _keywords.ContextualKeyword._async &&
        _index3.match.call(void 0, _types3.TokenType._function) &&
        !_util.canInsertSemicolon.call(void 0, )
      ) {
        _index3.next.call(void 0, );
        _statement.parseFunction.call(void 0, functionStart, false);
        return false;
      } else if (
        canBeArrow &&
        contextualKeyword === _keywords.ContextualKeyword._async &&
        !_util.canInsertSemicolon.call(void 0, ) &&
        _index3.match.call(void 0, _types3.TokenType.name)
      ) {
        _base.state.scopeDepth++;
        _lval.parseBindingIdentifier.call(void 0, false);
        _util.expect.call(void 0, _types3.TokenType.arrow);
        // let foo = async bar => {};
        parseArrowExpression(startTokenIndex);
        return true;
      } else if (_index3.match.call(void 0, _types3.TokenType._do) && !_util.canInsertSemicolon.call(void 0, )) {
        _index3.next.call(void 0, );
        _statement.parseBlock.call(void 0, );
        return false;
      }

      if (canBeArrow && !_util.canInsertSemicolon.call(void 0, ) && _index3.match.call(void 0, _types3.TokenType.arrow)) {
        _base.state.scopeDepth++;
        _lval.markPriorBindingIdentifier.call(void 0, false);
        _util.expect.call(void 0, _types3.TokenType.arrow);
        parseArrowExpression(startTokenIndex);
        return true;
      }

      _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index3.IdentifierRole.Access;
      return false;
    }

    case _types3.TokenType._do: {
      _index3.next.call(void 0, );
      _statement.parseBlock.call(void 0, );
      return false;
    }

    case _types3.TokenType.parenL: {
      const wasArrow = parseParenAndDistinguishExpression(canBeArrow);
      return wasArrow;
    }

    case _types3.TokenType.bracketL:
      _index3.next.call(void 0, );
      parseExprList(_types3.TokenType.bracketR, true);
      return false;

    case _types3.TokenType.braceL:
      parseObj(false, false);
      return false;

    case _types3.TokenType._function:
      parseFunctionExpression();
      return false;

    case _types3.TokenType.at:
      _statement.parseDecorators.call(void 0, );
    // Fall through.

    case _types3.TokenType._class:
      _statement.parseClass.call(void 0, false);
      return false;

    case _types3.TokenType._new:
      parseNew();
      return false;

    case _types3.TokenType.backQuote:
      parseTemplate();
      return false;

    case _types3.TokenType.doubleColon: {
      _index3.next.call(void 0, );
      parseNoCallExpr();
      return false;
    }

    case _types3.TokenType.hash: {
      const code = _index3.lookaheadCharCode.call(void 0, );
      if (_identifier.IS_IDENTIFIER_START[code] || code === _charcodes.charCodes.backslash) {
        parseMaybePrivateName();
      } else {
        _index3.next.call(void 0, );
      }
      // Smart pipeline topic reference.
      return false;
    }

    default:
      _util.unexpected.call(void 0, );
      return false;
  }
} exports.parseExprAtom = parseExprAtom;

function parseMaybePrivateName() {
  _index3.eat.call(void 0, _types3.TokenType.hash);
  parseIdentifier();
}

function parseFunctionExpression() {
  const functionStart = _base.state.start;
  parseIdentifier();
  if (_index3.eat.call(void 0, _types3.TokenType.dot)) {
    // function.sent
    parseIdentifier();
  }
  _statement.parseFunction.call(void 0, functionStart, false);
}

 function parseLiteral() {
  _index3.next.call(void 0, );
} exports.parseLiteral = parseLiteral;

 function parseParenExpression() {
  _util.expect.call(void 0, _types3.TokenType.parenL);
  parseExpression();
  _util.expect.call(void 0, _types3.TokenType.parenR);
} exports.parseParenExpression = parseParenExpression;

// Returns true if this was an arrow expression.
function parseParenAndDistinguishExpression(canBeArrow) {
  // Assume this is a normal parenthesized expression, but if we see an arrow, we'll bail and
  // start over as a parameter list.
  const snapshot = _base.state.snapshot();

  const startTokenIndex = _base.state.tokens.length;
  _util.expect.call(void 0, _types3.TokenType.parenL);

  let first = true;

  while (!_index3.match.call(void 0, _types3.TokenType.parenR) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      _util.expect.call(void 0, _types3.TokenType.comma);
      if (_index3.match.call(void 0, _types3.TokenType.parenR)) {
        break;
      }
    }

    if (_index3.match.call(void 0, _types3.TokenType.ellipsis)) {
      _lval.parseRest.call(void 0, false /* isBlockScope */);
      parseParenItem();
      break;
    } else {
      parseMaybeAssign(false, true);
    }
  }

  _util.expect.call(void 0, _types3.TokenType.parenR);

  if (canBeArrow && shouldParseArrow()) {
    const wasArrow = parseArrow();
    if (wasArrow) {
      // It was an arrow function this whole time, so start over and parse it as params so that we
      // get proper token annotations.
      _base.state.restoreFromSnapshot(snapshot);
      _base.state.scopeDepth++;
      // Don't specify a context ID because arrow functions don't need a context ID.
      _statement.parseFunctionParams.call(void 0, );
      parseArrow();
      parseArrowExpression(startTokenIndex);
      if (_base.state.error) {
        // Nevermind! This must have been something that looks very much like an
        // arrow function but where its "parameter list" isn't actually a valid
        // parameter list. Force non-arrow parsing.
        // See https://github.com/alangpierce/sucrase/issues/666 for an example.
        _base.state.restoreFromSnapshot(snapshot);
        parseParenAndDistinguishExpression(false);
        return false;
      }
      return true;
    }
  }

  return false;
}

function shouldParseArrow() {
  return _index3.match.call(void 0, _types3.TokenType.colon) || !_util.canInsertSemicolon.call(void 0, );
}

// Returns whether there was an arrow token.
 function parseArrow() {
  if (_base.isTypeScriptEnabled) {
    return _typescript.tsParseArrow.call(void 0, );
  } else if (_base.isFlowEnabled) {
    return _flow.flowParseArrow.call(void 0, );
  } else {
    return _index3.eat.call(void 0, _types3.TokenType.arrow);
  }
} exports.parseArrow = parseArrow;

function parseParenItem() {
  if (_base.isTypeScriptEnabled || _base.isFlowEnabled) {
    _types.typedParseParenItem.call(void 0, );
  }
}

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call ‚Äî at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.
function parseNew() {
  _util.expect.call(void 0, _types3.TokenType._new);
  if (_index3.eat.call(void 0, _types3.TokenType.dot)) {
    // new.target
    parseIdentifier();
    return;
  }
  parseNewCallee();
  if (_base.isFlowEnabled) {
    _flow.flowStartParseNewArguments.call(void 0, );
  }
  if (_index3.eat.call(void 0, _types3.TokenType.parenL)) {
    parseExprList(_types3.TokenType.parenR);
  }
}

function parseNewCallee() {
  parseNoCallExpr();
  _index3.eat.call(void 0, _types3.TokenType.questionDot);
}

 function parseTemplate() {
  // Finish `, read quasi
  _index3.nextTemplateToken.call(void 0, );
  // Finish quasi, read ${
  _index3.nextTemplateToken.call(void 0, );
  while (!_index3.match.call(void 0, _types3.TokenType.backQuote) && !_base.state.error) {
    _util.expect.call(void 0, _types3.TokenType.dollarBraceL);
    parseExpression();
    // Finish }, read quasi
    _index3.nextTemplateToken.call(void 0, );
    // Finish quasi, read either ${ or `
    _index3.nextTemplateToken.call(void 0, );
  }
  _index3.next.call(void 0, );
} exports.parseTemplate = parseTemplate;

// Parse an object literal or binding pattern.
 function parseObj(isPattern, isBlockScope) {
  // Attach a context ID to the object open and close brace and each object key.
  const contextId = _base.getNextContextId.call(void 0, );
  let first = true;

  _index3.next.call(void 0, );
  _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;

  while (!_index3.eat.call(void 0, _types3.TokenType.braceR) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      _util.expect.call(void 0, _types3.TokenType.comma);
      if (_index3.eat.call(void 0, _types3.TokenType.braceR)) {
        break;
      }
    }

    let isGenerator = false;
    if (_index3.match.call(void 0, _types3.TokenType.ellipsis)) {
      const previousIndex = _base.state.tokens.length;
      _lval.parseSpread.call(void 0, );
      if (isPattern) {
        // Mark role when the only thing being spread over is an identifier.
        if (_base.state.tokens.length === previousIndex + 2) {
          _lval.markPriorBindingIdentifier.call(void 0, isBlockScope);
        }
        if (_index3.eat.call(void 0, _types3.TokenType.braceR)) {
          break;
        }
      }
      continue;
    }

    if (!isPattern) {
      isGenerator = _index3.eat.call(void 0, _types3.TokenType.star);
    }

    if (!isPattern && _util.isContextual.call(void 0, _keywords.ContextualKeyword._async)) {
      if (isGenerator) _util.unexpected.call(void 0, );

      parseIdentifier();
      if (
        _index3.match.call(void 0, _types3.TokenType.colon) ||
        _index3.match.call(void 0, _types3.TokenType.parenL) ||
        _index3.match.call(void 0, _types3.TokenType.braceR) ||
        _index3.match.call(void 0, _types3.TokenType.eq) ||
        _index3.match.call(void 0, _types3.TokenType.comma)
      ) {
        // This is a key called "async" rather than an async function.
      } else {
        if (_index3.match.call(void 0, _types3.TokenType.star)) {
          _index3.next.call(void 0, );
          isGenerator = true;
        }
        parsePropertyName(contextId);
      }
    } else {
      parsePropertyName(contextId);
    }

    parseObjPropValue(isPattern, isBlockScope, contextId);
  }

  _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
} exports.parseObj = parseObj;

function isGetterOrSetterMethod(isPattern) {
  // We go off of the next and don't bother checking if the node key is actually "get" or "set".
  // This lets us avoid generating a node, and should only make the validation worse.
  return (
    !isPattern &&
    (_index3.match.call(void 0, _types3.TokenType.string) || // get "string"() {}
      _index3.match.call(void 0, _types3.TokenType.num) || // get 1() {}
      _index3.match.call(void 0, _types3.TokenType.bracketL) || // get ["string"]() {}
      _index3.match.call(void 0, _types3.TokenType.name) || // get foo() {}
      !!(_base.state.type & _types3.TokenType.IS_KEYWORD)) // get debugger() {}
  );
}

// Returns true if this was a method.
function parseObjectMethod(isPattern, objectContextId) {
  // We don't need to worry about modifiers because object methods can't have optional bodies, so
  // the start will never be used.
  const functionStart = _base.state.start;
  if (_index3.match.call(void 0, _types3.TokenType.parenL)) {
    if (isPattern) _util.unexpected.call(void 0, );
    parseMethod(functionStart, /* isConstructor */ false);
    return true;
  }

  if (isGetterOrSetterMethod(isPattern)) {
    parsePropertyName(objectContextId);
    parseMethod(functionStart, /* isConstructor */ false);
    return true;
  }
  return false;
}

function parseObjectProperty(isPattern, isBlockScope) {
  if (_index3.eat.call(void 0, _types3.TokenType.colon)) {
    if (isPattern) {
      _lval.parseMaybeDefault.call(void 0, isBlockScope);
    } else {
      parseMaybeAssign(false);
    }
    return;
  }

  // Since there's no colon, we assume this is an object shorthand.

  // If we're in a destructuring, we've now discovered that the key was actually an assignee, so
  // we need to tag it as a declaration with the appropriate scope. Otherwise, we might need to
  // transform it on access, so mark it as a normal object shorthand.
  let identifierRole;
  if (isPattern) {
    if (_base.state.scopeDepth === 0) {
      identifierRole = _index3.IdentifierRole.ObjectShorthandTopLevelDeclaration;
    } else if (isBlockScope) {
      identifierRole = _index3.IdentifierRole.ObjectShorthandBlockScopedDeclaration;
    } else {
      identifierRole = _index3.IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
    }
  } else {
    identifierRole = _index3.IdentifierRole.ObjectShorthand;
  }
  _base.state.tokens[_base.state.tokens.length - 1].identifierRole = identifierRole;

  // Regardless of whether we know this to be a pattern or if we're in an ambiguous context, allow
  // parsing as if there's a default value.
  _lval.parseMaybeDefault.call(void 0, isBlockScope, true);
}

function parseObjPropValue(
  isPattern,
  isBlockScope,
  objectContextId,
) {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsStartParseObjPropValue.call(void 0, );
  } else if (_base.isFlowEnabled) {
    _flow.flowStartParseObjPropValue.call(void 0, );
  }
  const wasMethod = parseObjectMethod(isPattern, objectContextId);
  if (!wasMethod) {
    parseObjectProperty(isPattern, isBlockScope);
  }
}

 function parsePropertyName(objectContextId) {
  if (_base.isFlowEnabled) {
    _flow.flowParseVariance.call(void 0, );
  }
  if (_index3.eat.call(void 0, _types3.TokenType.bracketL)) {
    _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
    parseMaybeAssign();
    _util.expect.call(void 0, _types3.TokenType.bracketR);
    _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
  } else {
    if (_index3.match.call(void 0, _types3.TokenType.num) || _index3.match.call(void 0, _types3.TokenType.string) || _index3.match.call(void 0, _types3.TokenType.bigint) || _index3.match.call(void 0, _types3.TokenType.decimal)) {
      parseExprAtom();
    } else {
      parseMaybePrivateName();
    }

    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index3.IdentifierRole.ObjectKey;
    _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
  }
} exports.parsePropertyName = parsePropertyName;

// Parse object or class method.
 function parseMethod(functionStart, isConstructor) {
  const funcContextId = _base.getNextContextId.call(void 0, );

  _base.state.scopeDepth++;
  const startTokenIndex = _base.state.tokens.length;
  const allowModifiers = isConstructor; // For TypeScript parameter properties
  _statement.parseFunctionParams.call(void 0, allowModifiers, funcContextId);
  parseFunctionBodyAndFinish(functionStart, funcContextId);
  const endTokenIndex = _base.state.tokens.length;
  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, true));
  _base.state.scopeDepth--;
} exports.parseMethod = parseMethod;

// Parse arrow function expression.
// If the parameters are provided, they will be converted to an
// assignable list.
 function parseArrowExpression(startTokenIndex) {
  parseFunctionBody(true);
  const endTokenIndex = _base.state.tokens.length;
  _base.state.scopes.push(new (0, _state.Scope)(startTokenIndex, endTokenIndex, true));
  _base.state.scopeDepth--;
} exports.parseArrowExpression = parseArrowExpression;

 function parseFunctionBodyAndFinish(functionStart, funcContextId = 0) {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsParseFunctionBodyAndFinish.call(void 0, functionStart, funcContextId);
  } else if (_base.isFlowEnabled) {
    _flow.flowParseFunctionBodyAndFinish.call(void 0, funcContextId);
  } else {
    parseFunctionBody(false, funcContextId);
  }
} exports.parseFunctionBodyAndFinish = parseFunctionBodyAndFinish;

 function parseFunctionBody(allowExpression, funcContextId = 0) {
  const isExpression = allowExpression && !_index3.match.call(void 0, _types3.TokenType.braceL);

  if (isExpression) {
    parseMaybeAssign();
  } else {
    _statement.parseBlock.call(void 0, true /* isFunctionScope */, funcContextId);
  }
} exports.parseFunctionBody = parseFunctionBody;

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

function parseExprList(close, allowEmpty = false) {
  let first = true;
  while (!_index3.eat.call(void 0, close) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      _util.expect.call(void 0, _types3.TokenType.comma);
      if (_index3.eat.call(void 0, close)) break;
    }
    parseExprListItem(allowEmpty);
  }
}

function parseExprListItem(allowEmpty) {
  if (allowEmpty && _index3.match.call(void 0, _types3.TokenType.comma)) {
    // Empty item; nothing more to parse for this item.
  } else if (_index3.match.call(void 0, _types3.TokenType.ellipsis)) {
    _lval.parseSpread.call(void 0, );
    parseParenItem();
  } else if (_index3.match.call(void 0, _types3.TokenType.question)) {
    // Partial function application proposal.
    _index3.next.call(void 0, );
  } else {
    parseMaybeAssign(false, true);
  }
}

// Parse the next token as an identifier.
 function parseIdentifier() {
  _index3.next.call(void 0, );
  _base.state.tokens[_base.state.tokens.length - 1].type = _types3.TokenType.name;
} exports.parseIdentifier = parseIdentifier;

// Parses await expression inside async function.
function parseAwait() {
  parseMaybeUnary();
}

// Parses yield expression inside generator.
function parseYield() {
  _index3.next.call(void 0, );
  if (!_index3.match.call(void 0, _types3.TokenType.semi) && !_util.canInsertSemicolon.call(void 0, )) {
    _index3.eat.call(void 0, _types3.TokenType.star);
    parseMaybeAssign();
  }
}

// https://github.com/tc39/proposal-js-module-blocks
function parseModuleExpression() {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._module);
  _util.expect.call(void 0, _types3.TokenType.braceL);
  // For now, just call parseBlockBody to parse the block. In the future when we
  // implement full support, we'll want to emit scopes and possibly other
  // information.
  _statement.parseBlockBody.call(void 0, _types3.TokenType.braceR);
}
