/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { LRUCache } from 'lru-cache';
import { posix, win32 } from 'path';
import type { Dirent, Stats } from 'fs';
import { Minipass } from 'minipass';
/**
 * An object that will be used to override the default `fs`
 * methods.  Any methods that are not overridden will use Node's
 * built-in implementations.
 *
 * - lstatSync
 * - readdir (callback `withFileTypes` Dirent variant, used for
 *   readdirCB and most walks)
 * - readdirSync
 * - readlinkSync
 * - realpathSync
 * - promises: Object containing the following async methods:
 *   - lstat
 *   - readdir (Dirent variant only)
 *   - readlink
 *   - realpath
 */
export interface FSOption {
    lstatSync?: (path: string) => Stats;
    readdir?: (path: string, options: {
        withFileTypes: true;
    }, cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any) => void;
    readdirSync?: (path: string, options: {
        withFileTypes: true;
    }) => Dirent[];
    readlinkSync?: (path: string) => string;
    realpathSync?: (path: string) => string;
    promises?: {
        lstat?: (path: string) => Promise<Stats>;
        readdir?: (path: string, options: {
            withFileTypes: true;
        }) => Promise<Dirent[]>;
        readlink?: (path: string) => Promise<string>;
        realpath?: (path: string) => Promise<string>;
        [k: string]: any;
    };
    [k: string]: any;
}
interface FSValue {
    lstatSync: (path: string) => Stats;
    readdir: (path: string, options: {
        withFileTypes: true;
    }, cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any) => void;
    readdirSync: (path: string, options: {
        withFileTypes: true;
    }) => Dirent[];
    readlinkSync: (path: string) => string;
    realpathSync: (path: string) => string;
    promises: {
        lstat: (path: string) => Promise<Stats>;
        readdir: (path: string, options: {
            withFileTypes: true;
        }) => Promise<Dirent[]>;
        readlink: (path: string) => Promise<string>;
        realpath: (path: string) => Promise<string>;
        [k: string]: any;
    };
    [k: string]: any;
}
export type Type = 'Unknown' | 'FIFO' | 'CharacterDevice' | 'Directory' | 'BlockDevice' | 'File' | 'SymbolicLink' | 'Socket';
/**
 * Options that may be provided to the Path constructor
 */
export interface PathOpts {
    fullpath?: string;
    relative?: string;
    relativePosix?: string;
    parent?: PathBase;
    /**
     * See {@link FSOption}
     */
    fs?: FSOption;
}
/**
 * An LRUCache for storing resolved path strings or Path objects.
 * @internal
 */
export declare class ResolveCache extends LRUCache<string, string> {
    constructor();
}
/**
 * an LRUCache for storing child entries.
 * @internal
 */
export declare class ChildrenCache extends LRUCache<PathBase, Children> {
    constructor(maxSize?: number);
}
/**
 * Array of Path objects, plus a marker indicating the first provisional entry
 *
 * @internal
 */
export type Children = PathBase[] & {
    provisional: number;
};
declare const setAsCwd: unique symbol;
/**
 * Path objects are sort of like a super-powered
 * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}
 *
 * Each one represents a single filesystem entry on disk, which may or may not
 * exist. It includes methods for reading various types of information via
 * lstat, readlink, and readdir, and caches all information to the greatest
 * degree possible.
 *
 * Note that fs operations that would normally throw will instead return an
 * "empty" value. This is in order to prevent excessive overhead from error
 * stack traces.
 */
export declare abstract class PathBase implements Dirent {
    #private;
    /**
     * the basename of this path
     *
     * **Important**: *always* test the path name against any test string
     * usingthe {@link isNamed} method, and not by directly comparing this
     * string. Otherwise, unicode path strings that the system sees as identical
     * will not be properly treated as the same path, leading to incorrect
     * behavior and possible security issues.
     */
    name: string;
    /**
     * the Path entry corresponding to the path root.
     *
     * @internal
     */
    root: PathBase;
    /**
     * All roots found within the current PathScurry family
     *
     * @internal
     */
    roots: {
        [k: string]: PathBase;
    };
    /**
     * a reference to the parent path, or undefined in the case of root entries
     *
     * @internal
     */
    parent?: PathBase;
    /**
     * boolean indicating whether paths are compared case-insensitively
     * @internal
     */
    nocase: boolean;
    /**
     * the string or regexp used to split paths. On posix, it is `'/'`, and on
     * windows it is a RegExp matching either `'/'` or `'\\'`
     */
    abstract splitSep: string | RegExp;
    /**
     * The path separator string to use when joining paths
     */
    abstract sep: string;
    get dev(): number | undefined;
    get mode(): number | undefined;
    get nlink(): number | undefined;
    get uid(): number | undefined;
    get gid(): number | undefined;
    get rdev(): number | undefined;
    get blksize(): number | undefined;
    get ino(): number | undefined;
    get size(): number | undefined;
    get blocks(): number | undefined;
    get atimeMs(): number | undefined;
    get mtimeMs(): number | undefined;
    get ctimeMs(): number | undefined;
    get birthtimeMs(): number | undefined;
    get atime(): Date | undefined;
    get mtime(): Date | undefined;
    get ctime(): Date | undefined;
    get birthtime(): Date | undefined;
    /**
     * This property is for compatibility with the Dirent class as of
     * Node v20, where Dirent['path'] refers to the path of the directory
     * that was passed to readdir.  So, somewhat counterintuitively, this
     * property refers to the *parent* path, not the path object itself.
     * For root entries, it's the path to the entry itself.
     */
    get path(): string;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name: string, type: number | undefined, root: PathBase | undefined, roots: {
        [k: string]: PathBase;
    }, nocase: boolean, children: ChildrenCache, opts: PathOpts);
    /**
     * Returns the depth of the Path object from its root.
     *
     * For example, a path at `/foo/bar` would have a depth of 2.
     */
    depth(): number;
    /**
     * @internal
     */
    abstract getRootString(path: string): string;
    /**
     * @internal
     */
    abstract getRoot(rootPath: string): PathBase;
    /**
     * @internal
     */
    abstract newChild(name: string, type?: number, opts?: PathOpts): PathBase;
    /**
     * @internal
     */
    childrenCache(): ChildrenCache;
    /**
     * Get the Path object referenced by the string path, resolved from this Path
     */
    resolve(path?: string): PathBase;
    /**
     * Returns the cached children Path objects, if still available.  If they
     * have fallen out of the cache, then returns an empty array, and resets the
     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
     * lookup.
     *
     * @internal
     */
    children(): Children;
    /**
     * Resolves a path portion and returns or creates the child Path.
     *
     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
     * `'..'`.
     *
     * This should not be called directly.  If `pathPart` contains any path
     * separators, it will lead to unsafe undefined behavior.
     *
     * Use `Path.resolve()` instead.
     *
     * @internal
     */
    child(pathPart: string, opts?: PathOpts): PathBase;
    /**
     * The relative path from the cwd. If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpath()
     */
    relative(): string;
    /**
     * The relative path from the cwd, using / as the path separator.
     * If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpathPosix()
     * On posix systems, this is identical to relative().
     */
    relativePosix(): string;
    /**
     * The fully resolved path string for this Path entry
     */
    fullpath(): string;
    /**
     * On platforms other than windows, this is identical to fullpath.
     *
     * On windows, this is overridden to return the forward-slash form of the
     * full UNC path.
     */
    fullpathPosix(): string;
    /**
     * Is the Path of an unknown type?
     *
     * Note that we might know *something* about it if there has been a previous
     * filesystem operation, for example that it does not exist, or is not a
     * link, or whether it has child entries.
     */
    isUnknown(): boolean;
    isType(type: Type): boolean;
    getType(): Type;
    /**
     * Is the Path a regular file?
     */
    isFile(): boolean;
    /**
     * Is the Path a directory?
     */
    isDirectory(): boolean;
    /**
     * Is the path a character device?
     */
    isCharacterDevice(): boolean;
    /**
     * Is the path a block device?
     */
    isBlockDevice(): boolean;
    /**
     * Is the path a FIFO pipe?
     */
    isFIFO(): boolean;
    /**
     * Is the path a socket?
     */
    isSocket(): boolean;
    /**
     * Is the path a symbolic link?
     */
    isSymbolicLink(): boolean;
    /**
     * Return the entry if it has been subject of a successful lstat, or
     * undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* simply
     * mean that we haven't called lstat on it.
     */
    lstatCached(): PathBase | undefined;
    /**
     * Return the cached link target if the entry has been the subject of a
     * successful readlink, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readlink() has been called at some point.
     */
    readlinkCached(): PathBase | undefined;
    /**
     * Returns the cached realpath target if the entry has been the subject
     * of a successful realpath, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * realpath() has been called at some point.
     */
    realpathCached(): PathBase | undefined;
    /**
     * Returns the cached child Path entries array if the entry has been the
     * subject of a successful readdir(), or [] otherwise.
     *
     * Does not read the filesystem, so an empty array *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readdir() has been called recently enough to still be valid.
     */
    readdirCached(): PathBase[];
    /**
     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
     * any indication that readlink will definitely fail.
     *
     * Returns false if the path is known to not be a symlink, if a previous
     * readlink failed, or if the entry does not exist.
     */
    canReadlink(): boolean;
    /**
     * Return true if readdir has previously been successfully called on this
     * path, indicating that cachedReaddir() is likely valid.
     */
    calledReaddir(): boolean;
    /**
     * Returns true if the path is known to not exist. That is, a previous lstat
     * or readdir failed to verify its existence when that would have been
     * expected, or a parent entry was marked either enoent or enotdir.
     */
    isENOENT(): boolean;
    /**
     * Return true if the path is a match for the given path name.  This handles
     * case sensitivity and unicode normalization.
     *
     * Note: even on case-sensitive systems, it is **not** safe to test the
     * equality of the `.name` property to determine whether a given pathname
     * matches, due to unicode normalization mismatches.
     *
     * Always use this method instead of testing the `path.name` property
     * directly.
     */
    isNamed(n: string): boolean;
    /**
     * Return the Path object corresponding to the target of a symbolic link.
     *
     * If the Path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     */
    readlink(): Promise<PathBase | undefined>;
    /**
     * Synchronous {@link PathBase.readlink}
     */
    readlinkSync(): PathBase | undefined;
    /**
     * Call lstat() on this Path, and update all known information that can be
     * determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    lstat(): Promise<PathBase | undefined>;
    /**
     * synchronous {@link PathBase.lstat}
     */
    lstatSync(): PathBase | undefined;
    /**
     * Standard node-style callback interface to get list of directory entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * @param cb The callback called with (er, entries).  Note that the `er`
     * param is somewhat extraneous, as all readdir() errors are handled and
     * simply result in an empty set of entries being returned.
     * @param allowZalgo Boolean indicating that immediately known results should
     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
     * zalgo at your peril, the dark pony lord is devious and unforgiving.
     */
    readdirCB(cb: (er: NodeJS.ErrnoException | null, entries: PathBase[]) => any, allowZalgo?: boolean): void;
    /**
     * Return an array of known child entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    readdir(): Promise<PathBase[]>;
    /**
     * synchronous {@link PathBase.readdir}
     */
    readdirSync(): PathBase[];
    canReaddir(): boolean;
    shouldWalk(dirs: Set<PathBase | undefined>, walkFilter?: (e: PathBase) => boolean): boolean;
    /**
     * Return the Path object corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     * On success, returns a Path object.
     */
    realpath(): Promise<PathBase | undefined>;
    /**
     * Synchronous {@link realpath}
     */
    realpathSync(): PathBase | undefined;
    /**
     * Internal method to mark this Path object as the scurry cwd,
     * called by {@link PathScurry#chdir}
     *
     * @internal
     */
    [setAsCwd](oldCwd: PathBase): void;
}
/**
 * Path class used on win32 systems
 *
 * Uses `'\\'` as the path separator for returned paths, either `'\\'` or `'/'`
 * as the path separator for parsing paths.
 */
export declare class PathWin32 extends PathBase {
    /**
     * Separator for generating path strings.
     */
    sep: '\\';
    /**
     * Separator for parsing path strings.
     */
    splitSep: RegExp;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name: string, type: number | undefined, root: PathBase | undefined, roots: {
        [k: string]: PathBase;
    }, nocase: boolean, children: ChildrenCache, opts: PathOpts);
    /**
     * @internal
     */
    newChild(name: string, type?: number, opts?: PathOpts): PathWin32;
    /**
     * @internal
     */
    getRootString(path: string): string;
    /**
     * @internal
     */
    getRoot(rootPath: string): PathBase;
    /**
     * @internal
     */
    sameRoot(rootPath: string, compare?: string): boolean;
}
/**
 * Path class used on all posix systems.
 *
 * Uses `'/'` as the path separator.
 */
export declare class PathPosix extends PathBase {
    /**
     * separator for parsing path strings
     */
    splitSep: '/';
    /**
     * separator for generating path strings
     */
    sep: '/';
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name: string, type: number | undefined, root: PathBase | undefined, roots: {
        [k: string]: PathBase;
    }, nocase: boolean, children: ChildrenCache, opts: PathOpts);
    /**
     * @internal
     */
    getRootString(path: string): string;
    /**
     * @internal
     */
    getRoot(_rootPath: string): PathBase;
    /**
     * @internal
     */
    newChild(name: string, type?: number, opts?: PathOpts): PathPosix;
}
/**
 * Options that may be provided to the PathScurry constructor
 */
export interface PathScurryOpts {
    /**
     * perform case-insensitive path matching. Default based on platform
     * subclass.
     */
    nocase?: boolean;
    /**
     * Number of Path entries to keep in the cache of Path child references.
     *
     * Setting this higher than 65536 will dramatically increase the data
     * consumption and construction time overhead of each PathScurry.
     *
     * Setting this value to 256 or lower will significantly reduce the data
     * consumption and construction time overhead, but may also reduce resolve()
     * and readdir() performance on large filesystems.
     *
     * Default `16384`.
     */
    childrenCacheSize?: number;
    /**
     * An object that overrides the built-in functions from the fs and
     * fs/promises modules.
     *
     * See {@link FSOption}
     */
    fs?: FSOption;
}
/**
 * The base class for all PathScurry classes, providing the interface for path
 * resolution and filesystem operations.
 *
 * Typically, you should *not* instantiate this class directly, but rather one
 * of the platform-specific classes, or the exported {@link PathScurry} which
 * defaults to the current platform.
 */
export declare abstract class PathScurryBase {
    #private;
    /**
     * The root Path entry for the current working directory of this Scurry
     */
    root: PathBase;
    /**
     * The string path for the root of this Scurry's current working directory
     */
    rootPath: string;
    /**
     * A collection of all roots encountered, referenced by rootPath
     */
    roots: {
        [k: string]: PathBase;
    };
    /**
     * The Path entry corresponding to this PathScurry's current working directory.
     */
    cwd: PathBase;
    /**
     * Perform path comparisons case-insensitively.
     *
     * Defaults true on Darwin and Windows systems, false elsewhere.
     */
    nocase: boolean;
    /**
     * The path separator used for parsing paths
     *
     * `'/'` on Posix systems, either `'/'` or `'\\'` on Windows
     */
    abstract sep: string | RegExp;
    /**
     * This class should not be instantiated directly.
     *
     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
     *
     * @internal
     */
    constructor(cwd: string | URL | undefined, pathImpl: typeof win32 | typeof posix, sep: string | RegExp, { nocase, childrenCacheSize, fs, }?: PathScurryOpts);
    /**
     * Get the depth of a provided path, string, or the cwd
     */
    depth(path?: Path | string): number;
    /**
     * Parse the root portion of a path string
     *
     * @internal
     */
    abstract parseRootPath(dir: string): string;
    /**
     * create a new Path to use as root during construction.
     *
     * @internal
     */
    abstract newRoot(fs: FSValue): PathBase;
    /**
     * Determine whether a given path string is absolute
     */
    abstract isAbsolute(p: string): boolean;
    /**
     * Return the cache of child entries.  Exposed so subclasses can create
     * child Path objects in a platform-specific way.
     *
     * @internal
     */
    childrenCache(): ChildrenCache;
    /**
     * Resolve one or more path strings to a resolved string
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolve(...paths: string[]): string;
    /**
     * Resolve one or more path strings to a resolved string, returning
     * the posix path.  Identical to .resolve() on posix systems, but on
     * windows will return a forward-slash separated UNC path.
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolvePosix(...paths: string[]): string;
    /**
     * find the relative path from the cwd to the supplied path string or entry
     */
    relative(entry?: PathBase | string): string;
    /**
     * find the relative path from the cwd to the supplied path string or
     * entry, using / as the path delimiter, even on Windows.
     */
    relativePosix(entry?: PathBase | string): string;
    /**
     * Return the basename for the provided string or Path object
     */
    basename(entry?: PathBase | string): string;
    /**
     * Return the dirname for the provided string or Path object
     */
    dirname(entry?: PathBase | string): string;
    /**
     * Return an array of known child entries.
     *
     * First argument may be either a string, or a Path object.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * Unlike `fs.readdir()`, the `withFileTypes` option defaults to `true`. Set
     * `{ withFileTypes: false }` to return strings.
     */
    readdir(): Promise<PathBase[]>;
    readdir(opts: {
        withFileTypes: true;
    }): Promise<PathBase[]>;
    readdir(opts: {
        withFileTypes: false;
    }): Promise<string[]>;
    readdir(opts: {
        withFileTypes: boolean;
    }): Promise<PathBase[] | string[]>;
    readdir(entry: PathBase | string): Promise<PathBase[]>;
    readdir(entry: PathBase | string, opts: {
        withFileTypes: true;
    }): Promise<PathBase[]>;
    readdir(entry: PathBase | string, opts: {
        withFileTypes: false;
    }): Promise<string[]>;
    readdir(entry: PathBase | string, opts: {
        withFileTypes: boolean;
    }): Promise<PathBase[] | string[]>;
    /**
     * synchronous {@link PathScurryBase.readdir}
     */
    readdirSync(): PathBase[];
    readdirSync(opts: {
        withFileTypes: true;
    }): PathBase[];
    readdirSync(opts: {
        withFileTypes: false;
    }): string[];
    readdirSync(opts: {
        withFileTypes: boolean;
    }): PathBase[] | string[];
    readdirSync(entry: PathBase | string): PathBase[];
    readdirSync(entry: PathBase | string, opts: {
        withFileTypes: true;
    }): PathBase[];
    readdirSync(entry: PathBase | string, opts: {
        withFileTypes: false;
    }): string[];
    readdirSync(entry: PathBase | string, opts: {
        withFileTypes: boolean;
    }): PathBase[] | string[];
    /**
     * Call lstat() on the string or Path object, and update all known
     * information that can be determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    lstat(entry?: string | PathBase): Promise<PathBase | undefined>;
    /**
     * synchronous {@link PathScurryBase.lstat}
     */
    lstatSync(entry?: string | PathBase): PathBase | undefined;
    /**
     * Return the Path object or string path corresponding to the target of a
     * symbolic link.
     *
     * If the path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     *
     * `{withFileTypes}` option defaults to `false`.
     *
     * On success, returns a Path object if `withFileTypes` option is true,
     * otherwise a string.
     */
    readlink(): Promise<string | undefined>;
    readlink(opt: {
        withFileTypes: false;
    }): Promise<string | undefined>;
    readlink(opt: {
        withFileTypes: true;
    }): Promise<PathBase | undefined>;
    readlink(opt: {
        withFileTypes: boolean;
    }): Promise<PathBase | string | undefined>;
    readlink(entry: string | PathBase, opt?: {
        withFileTypes: false;
    }): Promise<string | undefined>;
    readlink(entry: string | PathBase, opt: {
        withFileTypes: true;
    }): Promise<PathBase | undefined>;
    readlink(entry: string | PathBase, opt: {
        withFileTypes: boolean;
    }): Promise<string | PathBase | undefined>;
    /**
     * synchronous {@link PathScurryBase.readlink}
     */
    readlinkSync(): string | undefined;
    readlinkSync(opt: {
        withFileTypes: false;
    }): string | undefined;
    readlinkSync(opt: {
        withFileTypes: true;
    }): PathBase | undefined;
    readlinkSync(opt: {
        withFileTypes: boolean;
    }): PathBase | string | undefined;
    readlinkSync(entry: string | PathBase, opt?: {
        withFileTypes: false;
    }): string | undefined;
    readlinkSync(entry: string | PathBase, opt: {
        withFileTypes: true;
    }): PathBase | undefined;
    readlinkSync(entry: string | PathBase, opt: {
        withFileTypes: boolean;
    }): string | PathBase | undefined;
    /**
     * Return the Path object or string path corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     *
     * `{withFileTypes}` option defaults to `false`.
     *
     * On success, returns a Path object if `withFileTypes` option is true,
     * otherwise a string.
     */
    realpath(): Promise<string | undefined>;
    realpath(opt: {
        withFileTypes: false;
    }): Promise<string | undefined>;
    realpath(opt: {
        withFileTypes: true;
    }): Promise<PathBase | undefined>;
    realpath(opt: {
        withFileTypes: boolean;
    }): Promise<PathBase | string | undefined>;
    realpath(entry: string | PathBase, opt?: {
        withFileTypes: false;
    }): Promise<string | undefined>;
    realpath(entry: string | PathBase, opt: {
        withFileTypes: true;
    }): Promise<PathBase | undefined>;
    realpath(entry: string | PathBase, opt: {
        withFileTypes: boolean;
    }): Promise<string | PathBase | undefined>;
    realpathSync(): string | undefined;
    realpathSync(opt: {
        withFileTypes: false;
    }): string | undefined;
    realpathSync(opt: {
        withFileTypes: true;
    }): PathBase | undefined;
    realpathSync(opt: {
        withFileTypes: boolean;
    }): PathBase | string | undefined;
    realpathSync(entry: string | PathBase, opt?: {
        withFileTypes: false;
    }): string | undefined;
    realpathSync(entry: string | PathBase, opt: {
        withFileTypes: true;
    }): PathBase | undefined;
    realpathSync(entry: string | PathBase, opt: {
        withFileTypes: boolean;
    }): string | PathBase | undefined;
    /**
     * Async   éÏÿÿ¸   é<Ëÿÿ¸   é¶ÓÿÿB¶„*”D A‹Œ…4D IÍÿáÌÌÌÌ¸
   LCp‰E3Éé³Ëÿÿ¸   éXÔÿÿ‹ÂéÕÿÿM‰HH‹CI‰@‹C0A‰@E‰HA‰H…ö„‹×ÿÿWÀFé|×ÿÿ¸   éĞÿÿ¸   éÏÿÿƒ½ˆ   „…ÁÿÿAÆGé{ÁÿÿI‰@A‹ÑA‰é$÷ÿÿH‹D$@‹Ğ…Àˆ`ÂÿÿLCpE3ÉéÉîÿÿH‹D$@‹Ğ…ÀˆEÂÿÿLCpéSğÿÿ¸   éĞÿÿA‹ÁéÑÖÿÿ¸   é–Óÿÿ¸   éDĞÿÿ¸   é%Êÿÿ¸   éxÏÿÿ¸   éÊÿÿ¸   éÊÿÿ¸   éıÉÿÿ¸   éPÓÿÿ¸   ééÉÿÿ¸   écÒÿÿ¸   éÏÿÿ¸   éËÉÿÿ¸   éÆÿÿ¸   éÜÿÿ¸   éÂÏÿÿ¸   é&Çÿÿ¸   éÚÅÿÿ¸   éìÎÿÿ¸   éÇÿÿ¸   é@Ğÿÿ¸   é6Ğÿÿ¸	   égÉÿÿ¸   éÏÿÿ¸   éSÉÿÿ¸   éIÉÿÿ¸   é?Éÿÿ¸   éJÏÿÿ¸   éÚÿÿ¸   é¥Ñÿÿ¸   éoÍÿÿ¸   é$ÓÿÿI‰@A‹ÑA‰é_íÿÿI‰@3ÒE‰éôîÿÿH‹CA‹ÑI‰@‹C0A‰@AÇ    éóÙÿÿH…öt0H‹D$@ƒÂ÷H+ÇH‰~H‰FÇF   ‹C0‰Fƒút†ş	  ¸   ‰3Òé©Ûÿÿ¸   éÑÿÿ¸   éÃÄÿÿ¸   éóÈÿÿ¸   éñÅÿÿ¸   éßÈÿÿ¸   é›Äÿÿ¸   é‘Äÿÿ¸   éÌÿÿ¸   éÊÔÿÿ¸   ésÄÿÿ¸   é«Åÿÿ¸   é_Äÿÿ¸   é—Åÿÿ¸   éÏÎÿÿ¸   éƒÅÿÿ¸   éyÅÿÿÇ…p     AÆGéÆ¾ÿÿ¸   é5Ñÿÿ¸   éÄÿÿ¸   é‰Îÿÿ¸   éÎÿÿ¸   éÇÑÿÿ¸   ékÎÿÿ¸   éÅÿÿH‹D$@‹Ğ…Àˆt¿ÿÿLCpé;ùÿÿ¸   é?Îÿÿ¸   é5Îÿÿ¸   é¾ËÿÿÇ…p     é?¾ÿÿÇ…p     AÆGé+¾ÿÿH‹CA‹ÑI‰@‹C0A‰@AÇ    éÏÒÿÿ3ÒéÖÛÿÿ¸	   éUÃÿÿH‹D$@‹Ğ…Àˆì¾ÿÿLCpA¹   é~Ëÿÿ¸	   éoÄÿÿ¸   é#Ãÿÿ¸   éÃÿÿ¸   éÃÿÿ¸   éGÄÿÿ¸   é=Äÿÿ¸   é3Äÿÿ¸	   ékÍÿÿ¸   éùÏÿÿ¸   é Óÿÿ¸   éMÍÿÿ¸   éCÍÿÿ¸   é9ÍÿÿM‰HH‹CI‰@‹C0A‰@E‰HE‰(H…ö„ÖÿÿWÀFé€Öÿÿ¸   é³Æÿÿ¸   é©Æÿÿ¸   éŸÆÿÿ¸   é ×ÿÿ¸   é‹Æÿÿ¸   éÆÿÿ¸   éYÏÿÿ¸   évÎÿÿ¸   écÆÿÿ¸   éñÕÿÿ¸   éëÏÿÿ¸   é'Ëÿÿ¸	   é;ÆÿÿI‰@A‹ÑA‰éh÷ÿÿ¸   éËÿÿ¸   éÆÿÿ¸   éÆÿÿ¸   éÆÿÿ¸   é8Ëÿÿ¸   éùÍÿÿ¸   é"ãÿÿ¸   éGÖÿÿ¸   élËÿÿ¸   éËÿÿ¸   éÑÑÿÿ¸   éPÏÿÿ¸   éDËÿÿ¸   é`ãÿÿ¸   éŸÍÿÿ¸   é(ÏÿÿM‰HH‹CI‰@‹C0A‰@E‰HE‰(H…ö„t×ÿÿWÀFée×ÿÿ¸   écÑÿÿB¶„*lE A‹Œ…E IÍÿáÌÌÌÌ¸
   LCp‰éeÍÿÿ‹D$XH‹|$HéÆÿÿ¸   éğÉÿÿ¸   éæÉÿÿ¸   éÜÉÿÿ¸   éÒÉÿÿ¸   éÈÉÿÿ¸   é¼Öÿÿ¸   éÊÿÿ¸   éªÉÿÿ¸   éXÊÿÿ¸   éòÉÿÿ¸   é½Ğÿÿ¸   éŞÉÿÿ¸   éÔÉÿÿ¸   éiÈÿÿ¸   éíÔÿÿ¸   éÊÿÿ¸   é¬Éÿÿ¸   éüÓÿÿ¸   éôÉÿÿ¸   éoäÿÿ¸   éàÉÿÿ¸   éÈÿÿ¸   éÌÉÿÿD‹t$XéÔÅÿÿ¸   é\Éÿÿ¸	   éöÈÿÿ¸   é¤Éÿÿ¸   éâÈÿÿ¸   éØÈÿÿ¸   éÎÈÿÿ¸	   é Éÿÿ¸   éÁäÿÿ¸	   éhÉÿÿ¸   éÉÿÿ¸   éøÈÿÿ¸   éîÈÿÿ¸   éÔÿÿ¸   é6ÉÿÿLsp@ ff„     L‹ÎA¸   I‹ÖH‹ËèŒ” ‹Ğ…ÀˆØºÿÿ‹ƒøu?I‹FA¸   HC H‹ÖH‹Ëèòı ‹Ğ…Àˆ®ºÿÿ‹ƒøtAƒøu`I‹NÇ…p  1   ëƒø„»  …À„¤  H‹NHL$0ƒ½p   „uÿÿÿég¹ÿÿƒ~ uƒ~@uI‹FHD$0Ç…p  1   éC¹ÿÿƒ~ tšƒ~@t”H‹NHK ‹FAFINAGë LspA¸   I‹ÖH‹ËèBı ‹Ğ…Àˆş¹ÿÿI‹FPIF0IFAƒ>H‰D$0…ØÜÿÿAƒ~ …ÍÜÿÿAƒ~@…ÂÜÿÿÇ…p  2   é¿¸ÿÿÇ…p     ºå  ÀAÆGé¢¸ÿÿ¸   éÉÇÿÿ¸   é¿Çÿÿ¸   éıÊÿÿ¸   é©Ñÿÿ¸   ééÊÿÿ¸   é™Ëÿÿ¸   é^Òÿÿ¸   éÆÅÿÿ¸   é¼Åÿÿ¸   é²Åÿÿ¸   é¨Åÿÿ¸   éÅÿÿ¸   é”Åÿÿ¸   éÀÍÿÿ¸   é?Ëÿÿ¸   éyÓÿÿ¸	   élÅÿÿ¸   ébÅÿÿ¸   éXÅÿÿ¸   éNÅÿÿ¸   éIÊÿÿ¸   éfÉÿÿ¸   éïÊÿÿ¸   é+Êÿÿ¸   éHÉÿÿ¸   éÊÿÿ¸   éÊÿÿ¸   éÊÿÿ¸   é¯ĞÿÿH‹D$@‹Ğ…Àˆt¸ÿÿLCpéÅÊÿÿ¸   éÍÿÿ¸   éÍÉÿÿ¸   éÁÒÿÿ¸	   é¹Éÿÿ¸   éàÌÿÿ¸   é¥ÉÿÿLspA‹ÑM‰NH‹CI‰F‹C0A‰FE‰NE‰.é÷Òÿÿ¸   éuÉÿÿ¸   ékÉÿÿ¸   éêĞÿÿ¸   éĞÿÿH‹D$@‹Ğ…ÀˆÒ·ÿÿ¹   LCpE3Éé—ÌÿÿLspA‹ÑM‰NH‹CI‰F‹C0A‰FE‰NE‰.éAĞÿÿ¸   éaİÿÿ¸   é$Èÿÿ¸   éÑİÿÿH‹CA‹ÑI‰$‹C0A‰@A‰ÌéçÚÿÿE3ÉA‹Ñé^İÿÿ¸   éêÇÿÿ¸   éàÇÿÿ¸   éeÏÿÿ¸   éÌÇÿÿ¸   éÂÇÿÿ¸   éĞÿÿ¸   é®Çÿÿ¸   é¤çÿÿ¸	   éšÇÿÿ¸   éòÏÿÿ¸   é]Ñÿÿ¸   é|Çÿÿ¸   érÇÿÿ¸   éhÇÿÿLspA‹ÑM‰NH‹CI‰F‹C0A‰FE‰NAÇ   éÅÓÿÿ¸   éàçÿÿ¸   é:èÿÿB¶„*DF A‹Œ…äE IÍÿáÌÌÌÌ¸
   3Ò‰é‘Ñÿÿ¸   éßÿÿ¸   éÅĞÿÿLspA‹ÑM‰NH‹CI‰F‹C0A‰FE‰NAÇ   é
Ôÿÿ¸   éMÈÿÿ¸   é?Îÿÿ¸   é†ßÿÿ¸   é/Èÿÿ¸   éiĞÿÿ¸   é»Ûÿÿ¸   é5ÜÿÿLCpéİÿÿH‹CI‰$‹C0A‰@AÇ    éòÜÿÿM‰HA‹ÑH‹CI‰@‹C0E‰HAÇ    éÚÿÿ¸   é8Êÿÿ¸   é³Íÿÿ¸   é$Êÿÿ¸   éCÛÿÿƒø…¤¸ÿÿH»°   E‹ÁH‹×H‹Ëèø ‹Ğ…ÀˆKµÿÿƒ?tÌH‹G0HGƒ H‰D$0…h¸ÿÿƒ?…_¸ÿÿÇ…p     é´ÿÿ¸   é8Íÿÿ¸   éVÛÿÿ¸   é(ÇÿÿH‹CA‹ÑI‰@‹C0A‰@AÇ    éîİÿÿ3ÒéoßÿÿH‹D$@…ÀˆÆ´ÿÿLCpE3ÉéÍÿÿ¸   éàÆÿÿ¸   éÖÆÿÿ¸   éÌÆÿÿ¸   éÂÆÿÿ¸   é;İÿÿ¸   é®Æÿÿ¸   éèÎÿÿ¸   éÉÿÿ¸   é_Íÿÿ¸	   é†Æÿÿ¸   éóÈÿÿ¸   ééÈÿÿ¸   é7Íÿÿ¸   é^Æÿÿ¸   éËÈÿÿ¸   éJÆÿÿ¸   é@Æÿÿ¸   éƒİÿÿ¸   é£Èÿÿ¸   é™Èÿÿ¸   é¸Ùÿÿ¸   é‘Üÿÿ¸   éHÎÿÿ¸   éÚÿÿ¸	   égÈÿÿ¸   é]Èÿÿ¸   éSÈÿÿ¸   éIÈÿÿLspA‹ÑM‰NH‹CI‰F‹C0A‰FE‰NAÇ   é¸Õÿÿ¸   éâÍÿÿ¸   éáÜÿÿ¸   é*ÙÿÿH‹D$@…ÀˆM³ÿÿLCpE3ÉéàÍÿÿ¸   é6Ìÿÿ¸   éÙÿÿ¸   éÀãÿÿ¸   éÌÿÿ¸   éÌÿÿ¸   éÌÿÿ¸   éúËÿÿLCpA‹ÑM‰HH‹CI‰@‹C0A‰@E‰HA‰é¸ßÿÿ¸   éÊËÿÿ¸   é‘Øÿÿ¸   LCp‰E3Ééu»ÿÿ¸   éøØÿÿ¸   éããÿÿ¸   é=äÿÿ¸   é9Ûÿÿ¸	   é{Ëÿÿ¸   éqËÿÿ¸   égËÿÿ¸   é]Ëÿÿ¸   é€Êÿÿ¸   évÊÿÿ¸   é½Ûÿÿ¸   ééÚÿÿ¸   éßÚÿÿ¸   éŸÛÿÿ¸   éµâÿÿ¸   éŞ×ÿÿ¸   é0Êÿÿ¸   éNØÿÿE3ÉéËÿÿ¸   éÊÿÿ¸   é[Ûÿÿ¸   é Êÿÿ¸   éöÉÿÿ¸   éìÉÿÿ¸   éâÉÿÿ¸   éõâÿÿ¸   éOãÿÿ¸   éh×ÿÿ¸   éÌÿÿ¸   éøËÿÿ¸   éÎ×ÿÿ¸	   éœÉÿÿ¸   éâÿÿ¸   éˆÉÿÿ¸   é~Éÿÿ¸   étÉÿÿ¸   é×ÿÿ¸   éˆ×ÿÿ¸   éİÙÿÿ¸   éiâÿÿ¸   éÃâÿÿ¸   é€Ëÿÿ¸   éÚÿÿ¸   élËÿÿ¸   ébËÿÿ¸   é—Ùÿÿ¸   éNËÿÿ¸   éDËÿÿ¸   écáÿÿ¸   é0Ëÿÿ¸   éeÙÿÿ¸   é%Úÿÿ¸	   éËÿÿ¸   éËÿÿ¸   éşÊÿÿ¸   éôÊÿÿ¸   é¿áÿÿ¸   éâÿÿ¸   éÿàÿÿ¸   LCp‰E3Éé¹ÿÿ¸   éÂÙÿÿ¸   é„áÿÿ¸   éÎàÿÿ¸   éÔáÿÿ¸   éfáÿÿ¸   éÀáÿÿ¸   éÙÕÿÿ¸   LCp‰éÌÀÿÿ¸   é¿ÕÿÿH‹D$@‹Ğ…Àˆà¯ÿÿLCpé\Ôÿÿ¸   é!Öÿÿ¸   éÖÿÿ¸   LCp‰E3Ééw¸ÿÿ¸   éCàÿÿ¸   élÕÿÿ¸   ébÕÿÿ¸   éXÕÿÿ¸   éÒÕÿÿ¸   éDÕÿÿ¸   éØÿÿ¸   é0Õÿÿ¸   éªÕÿÿ¸   é•àÿÿ¸   éõ×ÿÿ¸   éŒÕÿÿ¸   éÛàÿÿ¸   éxÕÿÿ¸   éêÔÿÿ¸   édÕÿÿ¸   é£ßÿÿ¸   éPÕÿÿ¸   LCp‰E3Éé°·ÿÿ¸	   é¯Ôÿÿ¸   éRØÿÿ¸   é›Ôÿÿ¸   é>Øÿÿ¸   é‡Ôÿÿ¸   é}Ôÿÿ¸	   é÷Ôÿÿ¸   é6ßÿÿ¸   éØßÿÿ¸   éÙÔÿÿ¸   éÏÔÿÿ¸   éÅÔÿÿ¸   éàÿÿ¸   é¦ßÿÿ¸   é×ÿÿ¸   éößÿÿ¸   éòÖÿÿ¸   éèÖÿÿ¸   éŞÖÿÿ¸   éÔÖÿÿ¸   éÊÖÿÿ¸   éŠ×ÿÿ¸   LCp‰E3ÉéÁ¶ÿÿ¸   ém×ÿÿ¸   éc×ÿÿ¸   éY×ÿÿ¸	   é…Öÿÿ¸   éE×ÿÿ¸   éqÖÿÿ¸   égÖÿÿ¸   é]Öÿÿ¸   é×ÿÿ¸   LCp‰E3ÉéT¶ÿÿ¸	   é ×ÿÿ¸   éöÖÿÿ¸   éìÖÿÿ¸   éâÖÿÿ¸   LCp‰E3Éé¶ÿÿ¸   LCp‰é¾ÿÿ¸   3Ò‰é`Èÿÿ¸   éÇİÿÿ¸   é½İÿÿHC H»°   I‹@H‹×HD$0A¸   H‹Ëè5ğ ‹Ğ…Àˆñ¬ÿÿ‹ƒø…m  9G …  H‹G0HGHD$0Ç…p  -   é¾«ÿÿ¸   é Şÿÿ¸   éZŞÿÿ¸   éìİÿÿ¸   éFŞÿÿ¸   LCp‰E3ÉéMµÿÿ¸   éİÿÿ¸   éİÿÿ¸   éİÿÿ¸   éûÜÿÿ¸   éñÜÿÿM‰`LspH‹C3ÒI‰@3ÿ‹C0A‰@¸   ‰…p  E‰`AÇ    H‰|$0é«ÿÿ¸   LCp‰éÜ¼ÿÿ¸   éœÜÿÿ¸   LCp‰E3Éé³´ÿÿ¸   é+İÿÿ¸   é…İÿÿ¸   éİÿÿ¸   éİÿÿ¸   égİÿÿ¸   é]İÿÿ¸   éïÜÿÿ¸	   é9Üÿÿ¸   é?İÿÿ¸   éÑÜÿÿ¸   é+İÿÿ¸   éÜÿÿ¸   éÜÿÿ¸   éıÛÿÿ¸   LCp‰E3Éé´ÿÿ¸   éŒÜÿÿ¸   éæÜÿÿ¸   LCp‰éü»ÿÿ¸	   éhÜÿÿ¸	   éÂÜÿÿ¸   éTÜÿÿ¸   éJÜÿÿ¸   é@Üÿÿ¸   éšÜÿÿ¸   éÜÿÿ¸   é†Üÿÿ¸   LCp‰éœ»ÿÿ¸   3Ò‰éçÅÿÿ¸   LCp‰é~»ÿÿ¸   LCp‰én»ÿÿ¸   LCp‰E3ÉéO³ÿÿ¸   LCp‰E3Éé<³ÿÿ¸   LCp‰E3Éé)³ÿÿ¸   LCp‰E3Éé³ÿÿ¸   LCp‰E3Éé³ÿÿ¸   3Ò‰éZÅÿÿ¸   LCp‰E3Ééâ²ÿÿ¸   LCp‰E3ÉéÏ²ÿÿ¸   LCp‰éËºÿÿ¸   LCp‰E3Éé¬²ÿÿ¸	   LCp‰E3Éé™²ÿÿ¸   LCp‰E3Éé†²ÿÿ¸   LCp‰E3Éés²ÿÿ¸   LCp‰E3Éé`²ÿÿ¸   LCp‰é\ºÿÿ¸   3Ò‰é§Äÿÿ¸   LCp‰é>ºÿÿ¸   3Ò‰é‰Äÿÿ¸   3Ò‰é{Äÿÿ¸   3Ò‰émÄÿÿ¸   LCp‰éºÿÿ¸   LCp‰éô¹ÿÿ¸   3Ò‰é?Äÿÿ¸   LCp‰éÖ¹ÿÿ¸   LCp‰éÆ¹ÿÿ¸   LCp‰é¶¹ÿÿ¸   LCp‰é¦¹ÿÿ¸   LCp‰é–¹ÿÿ¸   3Ò‰éáÃÿÿ¸   LCp‰éx¹ÿÿ¸	   LCp‰éh¹ÿÿ¸   3Ò‰é³Ãÿÿ¸   LCp‰éJ¹ÿÿ¸   LCp‰é:¹ÿÿ¸   LCp‰é*¹ÿÿ¸   3Ò‰éuÃÿÿ¸   3Ò‰égÃÿÿ¸   3Ò‰éYÃÿÿ¸   3Ò‰éKÃÿÿ¸   3Ò‰é=Ãÿÿ¸   3Ò‰é/Ãÿÿ¸   3Ò‰é!Ãÿÿ¸   3Ò‰éÃÿÿ¸	   3Ò‰éÃÿÿ¸   3Ò‰é÷Âÿÿ¸   3Ò‰ééÂÿÿ¸   3Ò‰éÛÂÿÿ¸ï  ÀéÍ§ÿÿ¸ğ  ÀéÃ§ÿÿÇB   3Àé¥§ÿÿAÆGé§ÿÿAÆGé¥âÿÿƒø…“   ƒ LG …  H‹GLˆ  HC Hv, H‹Ëèú\  ‹Ğ…Àˆ:§ÿÿH‹O0H‹GHÁHD$0ƒ½ˆ   …WªÿÿHK HW@H‹Ëè‡C	 ‹Ğ…Àˆ§ÿÿH‹GPLspHD$0ƒ@…áÉÿÿÇ…p  0   éŞ¥ÿÿƒøuzE3ÀH‹×H‹Ëè” …ÀˆÂ¦ÿÿH‹ƒ@  HWLˆ  HÇD$     L
, H‹Ëÿ], ‹Ğ…Àˆ¦ÿÿƒ?tÌH‹GLspHD$0ƒ½ˆ   …bÉÿÿÇ…p  @   é_¥ÿÿH‹GHD$0éŠ©ÿÿHÇF    H‹CH‰F‹C0‰FÇF    Ç   éÖ¬ÿÿIƒÆM‰NMv H‹CI‰Fà‹C0A‰FğE‰NôAÇFØ   AƒÅÿu×é©ÿÿƒ»Ğ   …#©ÿÿÇ…p  )   é×¤ÿÿA¸   H“°   H‹Ëèÿè ‹Ğ…Àˆ»¥ÿÿH‹ƒà   HƒÀ   ƒ»°   H‰D$0…Èÿÿƒ»Ğ   …ƒÈÿÿÇ…p  )   é€¤ÿÿAÆGév¤ÿÿHƒÆHÇF    Hv H‹CH‰Fà‹C0‰FğÇFô    ÇFØ   AƒÅÿuÒéa´ÿÿA‹ÆéÌ®ÿÿL‰L$ LT* Lˆ  H‹×H‹Ëÿ[, é¡®ÿÿLˆ  HÇD$     L5* H‹×H‹ËÿY[, D‹ğé'¯ÿÿAÆGéŞ£ÿÿÇ…p     éÏ£ÿÿÇ…p  1   éÀ£ÿÿ¥Ğ  ñÙ  Û  Ûù   Ïõ  "ù  1÷  :ğ  bË  ô  ì  İá  ¬ o ?Ô  ıÒ  zÒ  ™Ş  Ïà  ,ñ  Ùî  òı  ôñ  ªÑ  Mü  ³ú  Tú  .  6ó  Bã  é  Ìæ   ë  Òì  uù  x   %	

	  %		      !!!"#%%%$$$$$$$ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ kÏ  9Ğ  Ï  Ğ  éÏ  Ğ  Ğ  ËÏ  ÕÏ  “Ï  ‰Ï  uÏ  ­Ï  ÁÏ  Ï  Ï  Ï  ßÏ  %Ğ  /Ğ  ·Ï  ıÏ  óÏ  øÍ      	
 éï  j ¤Õ   \ Ì B f ” pø  '÷  Eô  ñş     kù  
é  mô  R V ` rÿ  z p ıÑ      	
 cô  4	 ’×   ª _ ¯ ~ ˆ ûş  Jú  ¦÷   ¤ ^ÿ  „í  ôø  j ¹ *	 | ¾ ´ õË      	
 ÿ   °İ  \ 4 z Ş õ 	  ñ † ‘ „	 t Áõ     ò ü \	 H > J×      	
 7 w Óá  ' ë w 1 „ ¬  œ  ¢	 ß
 U Öø  f Ã c m ·
  õ ‹Ó      	
 A • 8ã  O  © Y ¢ À ( ¦ = 
 é
 } êø  „ ×  ‹ Á
 E 1 ÍÔ      	
 K Ñ 1å  Ë  Õ Ÿ Ê Ô t æ Q 
 * ¥ ù  Ö ; ½ Ç Ë
 Ÿ ‹ Ş      	
 ü ¼ •å  ?  ] … Í á R	 s 
 ı
 « z	 ,ú  ’  ¨ ² — 5 ! Å×      	
 Â Ô zæ  Ú ¼ ø ¬ {  Õ
 #
 ~  ¶ W öÿ  H	 ² À Ê * Ğ Æ §Ü      	
   æ  R  ¢ Ş Æ ø ó
 
 i ú è a 2  f	 î ü  p *   İ      	
 L › Âæ   H ¶ ò î   ­
 ‡    <  p	  $ ‘ ˜ z f _İ      	
  O èè  ÿ á 	 1 4 „ ÿ ¡ 	 . ß — U £
 × ; E ÿ õ ë ¢Û      	
 › 7 …ê  Ÿ w Õ é ¥ ¹  J ™
 m I R ò M Y ı - © • ‹ §à      	
